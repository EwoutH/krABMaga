use crate::engine::agent::Agent;
use crate::visualization::main_system_bundle::MainSystemBundle;
use crate::visualization::renderable::Render;
use crate::visualization::visualization_state::VisualizationState;
use amethyst::core::ecs::storage::DistinctStorage;
use amethyst::core::ecs::Component;
use amethyst::core::{SystemBundle, TransformBundle};
use amethyst::renderer::palette::Srgba;
use amethyst::renderer::{types::DefaultBackend, RenderFlat2D, RenderToWindow, RenderingBundle};
use amethyst::utils::application_root_dir;
use amethyst::{Application, GameDataBuilder};
use std::marker::PhantomData;
use std::path::PathBuf;

/// The application main struct, used to build and start the event loop. Offers several methods in a builder-pattern style
/// to allow for basic customization, such as background color, asset path and custom systems. Right now the framework
/// supports the automatic visualization of a single type of agents, due to generics limitation and the need to know at compile time
/// of the type of the agent, to actually know how much memory is required to store it in the Amethyst Storage types.
///
/// REQUIREMENTS:
/// 1) In the root of the project, a folder called `config` must be created and it must contain a display.ron file
///     which holds the settings for the window, such as window title and dimensions, see [amethyst::window::DisplayConfig]
/// 2) In the root of the project, a folder called `assets` must be created, it can be empty or it can contain
///     custom assets that can be loaded manually, it'll be the default source of the default Loader (see Amethyst docs)
pub struct Visualization<T>
where
    T: 'static + Agent + Render + Clone + Send + Sync,
    <T as Component>::Storage: DistinctStorage,
{
    /// The root path that will be used to fetch the display config and other configs from.
    root_path: PathBuf,
    /// The background color of the window generated by Amethyst.
    background_color: Srgba,
    /// A marker that allows for generic type use without actually storing it as a struct field.
    /// This is required because the agent will be passed all the way from here to the systems, in
    /// particular the Renderer System, to allow updating the graphics for each frame. In future this might
    /// be simplified to also allow automatic handling of multiple Render types.
    marker: PhantomData<T>,
}

impl<T> Visualization<T>
where
    T: 'static + Agent + Render + Clone + Send + Sync,
    <T as Component>::Storage: DistinctStorage,
{
    /// Pass a custom root dir that will be used to fetch the `config` and the `asset` folders. Useful if the
    /// project structure is non standard, or also to allow the use of this framework within examples.
    pub fn with_custom_root_dir(mut self, path: PathBuf) -> Visualization<T> {
        self.root_path = path;
        self
    }

    /// Pass a Srgba defining the color set to use to paint the background of the Amethyst window.
    pub fn with_background_color(mut self, background_color: Srgba) -> Visualization<T> {
        self.background_color = background_color;
        self
    }

    /// Build and start the Amethyst application with the necessary plugins and systems, along with optional
    /// custom systems defined by the user and grouped within a bundle for more complex simulation behaviour.
    /// The return value of this method should match the return value of the main function,
    /// where this method will be called and execute infinitely.
    pub fn start_with_custom_bundle<S: 'static + SystemBundle<'static, 'static>>(
        self,
        visualization_state: VisualizationState,
        custom_bundle: Option<S>,
    ) -> amethyst::Result<()> {
        amethyst::start_logger(Default::default());

        // Window config such as size and window title
        let display_config_path = self.root_path.join("config").join("display.ron");

        // The folder containing our assets, graphical and ron spritesheet configs
        let assets_dir = self.root_path.join("assets");
        let (r, g, b, a) = self.background_color.into_components();
        let main_bundle: MainSystemBundle<T> = MainSystemBundle {
            marker: PhantomData,
        };

        let mut game_data = GameDataBuilder::default()
            .with_bundle(
                RenderingBundle::<DefaultBackend>::new()
                    .with_plugin(
                        RenderToWindow::from_config_path(display_config_path)?
                            .with_clear([r, g, b, a]), // white opaque
                    )
                    .with_plugin(RenderFlat2D::default()),
            )?
            .with_bundle(TransformBundle::new())?
            .with_bundle(main_bundle)?;

        if let Some(bundle) = custom_bundle {
            game_data = game_data.with_bundle(bundle)?;
        }

        let mut game = Application::new(assets_dir, visualization_state, game_data)?;
        game.run();

        Ok(())
    }

    /// Start the Amethyst application without passing extra custom systems.
    pub fn start(self, visualization_state: VisualizationState) -> amethyst::Result<()> {
        self.start_with_custom_bundle(visualization_state, None::<MainSystemBundle<T>>)
    }
}

impl<T> Default for Visualization<T>
where
    T: 'static + Agent + Render + Clone + Send + Sync,
    <T as Component>::Storage: DistinctStorage,
{
    fn default() -> Self {
        Self {
            root_path: application_root_dir().unwrap(),
            background_color: Srgba::new(255., 255., 255., 1.),
            marker: PhantomData,
        }
    }
}
